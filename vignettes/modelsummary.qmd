---
title: "Model Summaries"
format: 
  html: default
---

```{css, echo=FALSE}
.table, th, td {
  font-size: 0.9em;
} 
.table tbody td, .table thead tr {
    white-space: nowrap;
}
```
```{r}
#| include: false
options(width = 10000)
options("tinytable_theme_placement_latex_float" = "H")
```

`modelsummary` includes a powerful set of utilities to customize the information displayed in your model summary tables. You can easily rename, reorder, subset or omit parameter estimates; choose the set of goodness-of-fit statistics to display; display various "robust" standard errors or confidence intervals; add titles, footnotes, or source notes; insert stars or custom characters to indicate levels of statistical significance; or add rows with supplemental information about your models.

Before starting, we set a few CSS properties to make tables more display in a more compact format on this website. This step is optional.

````{verbatim}
```{css, echo=FALSE}
.table, th, td {
  font-size: 0.9em;
} 
.table tbody td, .table thead tr {
    white-space: nowrap;
}
```
````


Now, we download data, fit some models, and summarize them in a table using the `modelsummary()` function:

```{r, message = FALSE}
library(modelsummary)

url <- 'https://vincentarelbundock.github.io/Rdatasets/csv/HistData/Guerry.csv'
dat <- read.csv(url)

models <- list(
  "OLS 1"     = lm(Donations ~ Literacy + Clergy, data = dat),
  "Poisson" = glm(Donations ~ Literacy + Commerce, family = poisson, data = dat),
  "OLS 2"     = lm(Crime_pers ~ Literacy + Clergy, data = dat)
)

modelsummary(models)
```

# `output`

The `output` argument determines the type of object returned by `modelsummary` and/or the file where this table should be written.

If you want to save a table directly to file, you can type:

```{r, eval=FALSE}
modelsummary(models, output = "table.docx")
modelsummary(models, output = "table.html")
modelsummary(models, output = "table.tex")
modelsummary(models, output = "table.md")
modelsummary(models, output = "table.txt")
modelsummary(models, output = "table.png")
```

If you want a raw HTML, LaTeX, or Markdown table, you can type:

```{r, eval=FALSE}
modelsummary(models, output = "html")
modelsummary(models, output = "latex")
modelsummary(models, output = "markdown")
```

If you to customize the appearance of your table using external tools like `gt`, `kableExtra`, `flextable`, or `huxtable`, you can type:

```{r, eval=FALSE}
modelsummary(models, output = "gt")
modelsummary(models, output = "kableExtra")
modelsummary(models, output = "flextable")
modelsummary(models, output = "huxtable")
```

Warning: When a file name is supplied to the `output` argument, the table is written immediately to file. If you want to customize your table by post-processing it with an external package, you need to choose a different output format and saving mechanism.  The saving function differs from package to package:

* `tinytable`: set `output="tinytable"`, post-process your table, and use the `tinytable::save_tt()` function.
* `gt`: set `output="gt"`, post-process your table, and use the `gt::gtsave()` function.
* `kableExtra`: set `output` to your destination format (e.g., "latex", "html", "markdown"), post-process your table, and use `kableExtra::save_kable()` function.

For example:

```{r}
#| eval: false
library(tinytable)
modelsummary(models, output = "tinytable") |>
  style_tt(i = 1, background = "pink") |>
  save_tt("table.html")
```

# `fmt`

The `fmt` argument defines how numeric values are rounded and presented in the table. This argument accepts three types of input:

* Integer: Number of decimal digits
* User-supplied function: Accepts a numeric vector and returns a character vector of the same length.
* `modelsummary` function: `fmt_decimal()`, `fmt_significant()`, `fmt_sprintf()`, `fmt_term()`, `fmt_statistic`, `fmt_identity()`

Examples:

```{r, eval=FALSE}
mod <- lm(mpg ~ hp + drat + qsec, data = mtcars)

# decimal digits
modelsummary(mod, fmt = 3)

# user-supplied function
modelsummary(mod, fmt = function(x) round(x, 2))

# p values with different number of digits
modelsummary(mod, fmt = fmt_decimal(1, 3), statistic = c("std.error", "p.value"))

# significant digits
modelsummary(mod, fmt = fmt_significant(3))

# sprintf(): decimal digits
modelsummary(mod, fmt = fmt_sprintf("%.5f"))

# sprintf(): scientific notation 
modelsummary(mod, fmt = fmt_sprintf("%.5e"))

# statistic-specific formatting
modelsummary(mod, fmt = fmt_statistic(estimate = 4, conf.int = 1), statistic = "conf.int")

# term-specific formatting
modelsummary(mod, fmt = fmt_term(hp = 4, drat = 1, default = fmt_significant(2)))

modelsummary(mod, fmt = NULL)
```

:::: {.content-visible when-format="html"}
Custom formatting function with big mark commas:

```{r}
modf <- lm(I(mpg * 100) ~ hp, mtcars)
f <- function(x) formatC(x, digits = 2, big.mark = ",", format = "f")
modelsummary(modf, fmt = f, gof_map = NA)
```
::::

In many languages the comma is used as a decimal mark instead of the period.  `modelsummary` respects the global `R` `OutDec` option, so you can simply execute this command and your tables will be adjusted automatically:

```{r, eval=FALSE}
options(OutDec=",")
```

# `estimate`

By default, `modelsummary` prints each coefficient estimate on its own row. You can customize this by changing the `estimate` argument. For example, this would produce a table of p values instead of coefficient estimates:

```{r, eval=FALSE}
modelsummary(models, estimate = "p.value")
```

You can also use [glue string](https://glue.tidyverse.org/), using curly braces to specify the statistics you want. For example, this displays the estimate next to a confidence interval: 

```{r}
modelsummary(
  models,
  fmt = 1,
  estimate  = "{estimate} [{conf.low}, {conf.high}]",
  statistic = NULL,
  coef_omit = "Intercept")
```

Glue strings can also apply R functions to estimates. However, since `modelsummary` rounds numbers and transforms them to character by default, we must set `fmt = NULL`:

```{r}
m <- glm(am ~ mpg, data = mtcars, family = binomial)
modelsummary(
    m,
    fmt = NULL,
    estimate = "{round(exp(estimate), 5)}",
    statistic = "{round(exp(estimate) * std.error, 3)}")
```

You can also use different estimates for different models by using a vector of strings:

```{r}
modelsummary(
  models,
  fmt = 1,
  estimate  = c("estimate",
                "{estimate}{stars}",
                "{estimate} ({std.error})"),
  statistic = NULL,
  coef_omit = "Intercept")
```


# `statistic`

By default, `modelsummary` prints the coefficient's standard error in parentheses below the corresponding estimate. The value of this uncertainty statistic is determined by the `statistic` argument. The `statistic` argument accepts any of the column names produced by `get_estimates(model)`. For example:

```{r, eval=FALSE}
modelsummary(models, statistic = 'std.error')
modelsummary(models, statistic = 'p.value')
modelsummary(models, statistic = 'statistic')
```

You can also display confidence intervals in brackets by setting `statistic="conf.int"`:

```{r}
modelsummary(models,
             fmt = 1,
             statistic = 'conf.int', 
             conf_level = .99)
```

Alternatively, you can supply a [glue string](https://glue.tidyverse.org/) to get more complicated results:

```{r}
modelsummary(models,
             statistic = "{std.error} ({p.value})")
```

You can also display several different uncertainty estimates below the coefficient estimates by using a vector. For example,

```{r}
modelsummary(models, gof_omit = ".*",
             statistic = c("conf.int",
                           "s.e. = {std.error}", 
                           "t = {statistic}",
                           "p = {p.value}"))
```

Setting `statistic=NULL` omits all statistics. This can often be useful if, for example, you want to display confidence intervals next to coefficients: 

```{r}
modelsummary(models, gof_omit = ".*",
             estimate = "{estimate} [{conf.low}, {conf.high}]",
             statistic = NULL)
```

# `vcov`

You can use clustered or robust uncertainty estimates by modifying the `vcov` parameter. This function accepts 5 different types of input.  You can use a string or a vector of strings:

```r
modelsummary(models, vcov = "robust")
modelsummary(models, vcov = c("classical", "HC3", "bootstrap"))
```

These variance-covariance matrices are calculated using the `sandwich` package. You can pass arguments to the `sandwich` functions directly from the `modelsummary` function. For instance, to change the number of bootstrap replicates and to specify a clustering variable we could call:

```r
modelsummary(mod, vcov = "bootstrap", R = 1000, cluster = "country")
```

You can use a one-sided formula or list of one-sided formulas to use clustered standard errors:

```r
modelsummary(models, vcov = ~Region)
```

You can specify a function that produces variance-covariance matrices:

```r
library(sandwich)
modelsummary(models, vcov = vcovHC)
```

You can supply a list of functions of the same length as your model list:

```r
modelsummary(models, 
  vcov = list(vcov, vcovHC, vcovHAC, vcovHC, vcov))
```

You can supply a list of named variance-covariance matrices:

```r
vcov_matrices <- lapply(models, vcovHC)
modelsummary(models, vcov = vcov_matrices)
```

You can supply a list of named vectors:

```r
vc <- list(
  `OLS 1` = c(`(Intercept)` = 2, Literacy = 3, Clergy = 4), 
  `Poisson` = c(`(Intercept)` = 3, Literacy = -5, Commerce = 3),
  `OLS 2` = c(`(Intercept)` = 7, Literacy = -6, Clergy = 9)
  )
modelsummary(models, vcov = vc)
```

# `stars`

Some people like to add "stars" to their model summary tables to mark statistical significance. The `stars` argument can take three types of input:

1. `NULL` omits any stars or special marks (default)
2. `TRUE` uses these default values: `+ p < 0.1, * p < 0.05, ** p < 0.01, *** p < 0.001`
3. Named numeric vector for custom stars.

```r
modelsummary(models)
modelsummary(models, stars = TRUE) 
modelsummary(models, stars = c('+' = .1, '&' = .01)) 
```

Whenever `stars` is not `NULL`, `modelsummary` adds a note at the bottom of the table automatically. If you would like to add stars but *not* include a note at the bottom of the table, you can define the display of your estimate manually using a `glue` string, as described in the [`estimate` argument section of the documentation.](https://modelsummary.com/vignettes/modelsummary.html#estimate-1) Whenever the `{stars}` string appears in the `estimate` or `statistic` arguments, `modelsummary` will assume that you want fine-grained control over your table, and will *not* include a note about stars.

```{r}
modelsummary(models,
             estimate = "{estimate}{stars}",
             gof_omit = ".*")
```

If you want to create your own stars description, you can add custom notes with the [`notes`](https://github.com/vincentarelbundock/modelsummary#notes) argument.


# `coef_omit`

An alternative mechanism to subset coefficients is to use the `coef_omit` argument, which accepts a vector of integer or a regular expression. For example, we can omit the first and second coefficients as follows:

```{r}
modelsummary(models, coef_omit = 1:2, gof_map = NA)
```

Negative indices determine which coefficients to *keep*:

```{r}
modelsummary(models, coef_omit = c(-1, -2), gof_map = NA)
```

When `coef_omit` is a string, it is fed to `grepl(x,perl=TRUE)` to detect the variable names which should be excluded from the table.

```{r}
modelsummary(models, coef_omit = "Intercept|.*merce", gof_map = NA)
```

Since `coef_omit` accepts regexes, you can do interesting things with it, such as specifying the list of variables that `modelsummary` should *keep* instead of omit. To do this, we use [a negative lookahead.](https://www.regular-expressions.info/lookaround.html) To keep only the coefficients *starting* with "Lit", we call:

```{r}
modelsummary(models, coef_omit = "^(?!Lit)", gof_map = NA)
```

To keep all coefficients matching the "y" substring:

```{r}
modelsummary(models, coef_omit = "^(?!.*y)", gof_map = NA)
```

To keep all coefficients matching one of two substrings:

```{r}
modelsummary(models, coef_omit = "^(?!.*tercept|.*y)", gof_map = NA)
```

# `coef_rename`

`modelsummary` offers powerful and innovative mechanisms to rename, reorder, and subset coefficients and goodness-of-fit statistics.

You can rename coefficients using the `coef_rename` argument. For example, if you have two models with different explanatory variables, but you want both variables to have the same name and appear on the same row, you can do:

```{r}
x <- list(lm(hp ~ drat, mtcars),
          lm(hp ~ vs, mtcars))

modelsummary(x, coef_rename = c("drat" = "Explanator", "vs" = "Explanator"))
```

If you provide a named character vector to `coef_rename`, only exact matches of the *complete* original term name will be replaced.  

For complex modifications, you can feed a function which returns a named vector to the `coef_rename` argument. For example, `modelsummary` ships with a function called `coef_rename`, which executes some common renaming tasks automatically. This example also uses the `dvnames` function to extract the name of the dependent variable in each model:

```{r}
x <- list(
  lm(mpg ~ factor(cyl) + drat + disp, data = mtcars),
  lm(hp ~ factor(cyl) + drat + disp, data = mtcars)
)

modelsummary(dvnames(x), coef_rename = coef_rename)
```

Of course, you can also define your own custom functions. For instance, to rename a model with interacted variables (e.g., "drat:mpg"), you could define a custom `rename_explanator` function:

```{r}
y <- list(
  lm(hp ~ drat / mpg, mtcars),
  lm(hp ~ vs / mpg, mtcars)
)

rename_explanator <- function(old_names) {
  new_names <- gsub("drat|vs", "Explanator", old_names)
  setNames(new_names, old_names)
}

modelsummary(y, coef_rename = rename_explanator)
```

Beware of inadvertently replacing parts of other variable names! Making your regex pattern as specific as possible (e.g., by adding word boundaries) is likely a good idea. The custom rename function is also a good place to re-introduce the replacement of ":" with "×" if you are dealing with interaction terms -- `modelsummary` makes this replacement for you only when the `coef_rename` argument is not specified.

Another possibility is to assign variable labels to attributes in the data used to fit the model. Then, we can automatically rename them:

```{r}
datlab <- mtcars
datlab$cyl <- factor(datlab$cyl)
attr(datlab$cyl, "label") <- "Cylinders"
attr(datlab$am, "label") <- "Transmission"
modlab <- lm(mpg ~ cyl + am, data = datlab)
modelsummary(modlab, coef_rename = TRUE)
```

# `coef_map`

The `coef_map` argument is a named vector which allows users to rename, reorder, and subset coefficient estimates. Values of this vector correspond to the "clean" variable name. Names of this vector correspond to the "raw" variable name. The table will be sorted in the order in which terms are presented in `coef_map`. Coefficients which are *not* included in `coef_map` will be excluded from the table.

```{r}
cm <- c('Literacy'    = 'Literacy (%)',
        'Commerce'    = 'Patents per capita',
        '(Intercept)' = 'Constant')
modelsummary(models, coef_map = cm)
```

# `gof_omit`

`gof_omit` is a regular expression which will be fed to `grepl(x,perl=TRUE)` to detect the names of the statistics which should be excluded from the table.

```r
modelsummary(models, gof_omit = 'DF|Deviance|R2|AIC|BIC')
```

# `gof_map`

The `gof_map` argument can be used to rename, re-order, subset, and format the statistics displayed in the bottom section of the table ("goodness-of-fit").

The first type of values allowed is a character vector with elements equal to column names in the data.frame produced by `get_gof(model)`:

```{r}
modelsummary(models, gof_map = c("nobs", "r.squared"))
```

A more powerful mechanism is to supply a `data.frame` (or `tibble`) through the `gof_map` argument. This data.frame must include 3 columns:

1. `raw`: a string with the name of a column produced by `get_gof(model)`.
2. `clean`: a string with the "clean" name of the statistic you want to appear in your final table.
3. `fmt`: a string which will be used to round/format the string in question (e.g., `"%.3f"`). This follows the same standards as the `fmt` argument in `?modelsummary`.

You can see an example of a valid data frame by typing `modelsummary::gof_map`. This is the default data.frame that `modelsummary` uses to subset and reorder goodness-of-fit statistics. As you can see, `omit == TRUE` for quite a number of statistics. You can include setting `omit == FALSE`: 

```r
gm <- modelsummary::gof_map
gm$omit <- FALSE
modelsummary(models, gof_map = gm)
```

The goodness-of-fit statistics will be printed in the table in the same order as in the `gof_map` data.frame.

```r
f <- function(x) format(round(x, 3), big.mark=",")
gm <- list(
  list("raw" = "nobs", "clean" = "N", "fmt" = f),
  list("raw" = "AIC", "clean" = "aic", "fmt" = f))
modelsummary(models, gof_map = gm)
```

Another convenient way to build a `gof_map` argument is to use the `tribble` function from the `tibble` package. In this example, we insert special HTML code to display a superscript, so we use the `escape=FALSE` argument.

Warning: This `tribble` syntax may not work well when `fmt` is a function. In that case, please revert to the list syntax illustrated above.

```{r}
gm <- tibble::tribble(
  ~raw,        ~clean,          ~fmt,
  "nobs",      "N",             0,
  "r.squared", "R<sup>2</sup>", 2)

modelsummary(
  models,
  statistic = NULL,
  gof_map = gm,
  escape = FALSE)
```

# `gof_function`

The `gof_function` argument accepts a function which processes the model and returns a data frame with custom information about each model. For example, we can insert a row in the bottom portion of the table to display the dependent variable with:

```{r}
mod <- list(
    lm(mpg ~ qsec + drat, mtcars),
    lm(hp ~ qsec + drat, mtcars)
)

fun <- function(model) data.frame("DV" = insight::find_response(model))

modelsummary(mod, gof_function = fun)
```

In this example, we write a function factory to insert an indicator for whether a model includes control variables:

```{r}
mod <- list(
    lm(wt ~ qsec, data = mtcars),
    lm(wt ~ qsec + hp + mpg, data = mtcars)
)

check_controls <- function(variables, yes = "✓", no = "") {
    checkmate::assert_character(variables, min.len = 1)
    checkmate::assert_string(no)
    checkmate::assert_string(yes)
    reg <- paste0("^", paste(variables, collapse = "$|^"), "$")
    fun <- function(model) {
        est <- get_estimates(model)
        df <- if (all(variables %in% est$term)) yes else no
        df <- data.frame(Controls = df)
        return(df)
    }
    list("fun" = fun, "regex" = reg)
}

cc <- check_controls(c("hp", "mpg"))

modelsummary(mod, 
    gof_function = cc$fun, 
    coef_omit = cc$regex)
```


# `shape`

This section requires version 1.3.1 of `modelsummary`. If this version is not available on CRAN yet, you can install the development version by following [the instructions on the website.](https://modelsummary.com/#installation)

The `shape` argument accepts:

1. A formula which determines the structure of the table, and can display "grouped" coefficients together (e.g., multivariate outcome or mixed-effects models). 
2. The strings "cbind", "rbind" or "rcollapse" to stack multiple tables on top of each other and present models in distinct "panels".

## Formula

The left side of the formula represents the rows and the right side represents the columns. The default formula is `term + statistic ~ model`:

```{r}
m <- list(
    lm(mpg ~ hp, data = mtcars),
    lm(mpg ~ hp + drat, data = mtcars))

modelsummary(m, shape = term + statistic ~ model, gof_map = NA)
```

We can display statistics horizontally with:

```{r}
modelsummary(m,
             shape = term ~ model + statistic,
             statistic = "conf.int",
             gof_map = NA)
```

The order of terms in the formula determines the order of headers in the table.

```{r}
modelsummary(m,
             shape = term ~ statistic + model,
             statistic = "conf.int",
             gof_map = NA)
```

`shape` does partial matching and will try to fill-in incomplete formulas:

```{r, eval = FALSE}
modelsummary(m, shape = ~ statistic)
```

Some models like multinomial logit or GAMLSS produce "grouped" parameter estimates. To display these groups, we can include a group identifier in the `shape` formula. This group identifier must be one of the column names produced by `get_estimates(model)`. For example, in models produced by `nnet::multinom`, the group identifier is called "response":

```{r, message = FALSE}
library(nnet)

dat_multinom <- mtcars
dat_multinom$cyl <- sprintf("Cyl: %s", dat_multinom$cyl)

mod <- list(
    nnet::multinom(cyl ~ mpg, data = dat_multinom, trace = FALSE),
    nnet::multinom(cyl ~ mpg + drat, data = dat_multinom, trace = FALSE))

get_estimates(mod[[1]])
```

To summarize the results, we can type: 

```{r, warning=FALSE}
# modelsummary(mod, shape = term + response ~ statistic)
```

The terms of the `shape` formula above can of course be rearranged to reshape the table. For example:

```{r, warning=FALSE}
modelsummary(mod, shape = model + term ~ response)
```

We can combine the `term` and group identifier columns by inserting an interaction colon `:` instead of the `+` in the formula:

```{r, warning = FALSE, message = FALSE}
library(marginaleffects)
mod <- glm(am ~ mpg + factor(cyl), family = binomial, data = mtcars)
mfx <- avg_slopes(mod)

modelsummary(mfx, shape = term + contrast ~ model)
```

```{r}
modelsummary(mfx, shape = term : contrast ~ model)
```

## String ("rbind" or "rcollapse"): Panels of models in stacked regression tables

Note: The code in this section requires version 1.3.0 or the development version of `modelsummary`. See [the website](https://modelsummary.com/index.html) for installation instructions.

This section shows how to  "stack/bind" multiple regression tables on top of one another, to display the results several models side-by-side and top-to-bottom. For example, imagine that we want to present 4 different models, half of which are estimated using a different outcome variable. When using `modelsummary`, we store models in a list. When using `modelsummary` with `shape="rbind"` or `shape="rbind"`, we store models in a list of lists:

```{r}
gm <- c("r.squared", "nobs", "rmse")

panels <- list(
  list(
    lm(mpg ~ 1, data = mtcars),
    lm(mpg ~ qsec, data = mtcars)
  ),
  list(
    lm(hp ~ 1, data = mtcars),
    lm(hp ~ qsec, data = mtcars)
  )
)

modelsummary(
  panels,
  shape = "rbind",
  gof_map = gm)
```

Like with `modelsummary()`, we can can name models and panels by naming elements of our nested list:

```{r}
panels <- list(
  "Outcome: mpg" = list(
    "(I)" = lm(mpg ~ 1, data = mtcars),
    "(II)" = lm(mpg ~ qsec, data = mtcars)
  ),
  "Outcome: hp" = list(
    "(I)" = lm(hp ~ 1, data = mtcars),
    "(II)" = lm(hp ~ qsec, data = mtcars)
  )
)

modelsummary(
  panels,
  shape = "rbind",
  gof_map = gm)
```

## String ("cbind"): Automatic spanning column labels

When using the default `tinytable` backend, we can use a named nested list to automatically add spanning column labels to a table:

```{r}
modelsummary(panels, shape = "cbind")
```

## Renaming estimates and statistics

When statistics are displayed in different columns, users may want control over the statistic names. To do so, we specify the `estimate` and `statistic` as named vectors:


```{r}
mod <- lm(mpg ~ factor(cyl), mtcars)

modelsummary(
    mod, 
    estimate = c("$\\hat{\\beta}$" = "estimate"),
    statistic = c("$\\sigma_{\\hat{\\beta}}$" = "std.error"),
    shape = term ~ model + statistic)
```


### `fixest`

The `fixest` package offers powerful tools to estimate multiple models using a concise syntax. `fixest` functions are also convenient because they return named lists of models which are easy to subset and manipulate using standard `R` functions like `grepl`. 

For example, to introduce regressors in stepwise fashion, and to estimate models on different subsets of the data, we can do:

```{r}
#| message = FALSE

# estimate 4 models
library(fixest)
mod <- feols(
  c(hp, mpg) ~ csw(qsec, drat) | gear,
  data = mtcars)

# select models with different outcome variables
panels <- list(
  "Miles per gallon" = mod[grepl("mpg", names(mod))],
  "Horsepower" = mod[grepl("hp", names(mod))]
)

modelsummary(
  panels,
  shape = "rcollapse",
  gof_omit = "IC|R2")
```

We can use all the typical extension systems to add information, such as the mean of the dependent variable:

```{r}
glance_custom.fixest <- function(x, ...) {
  dv <- insight::get_response(x)
  dv <- sprintf("%.2f", mean(dv, na.rm = TRUE))
  data.table::data.table(`Mean of DV` = dv)
}

modelsummary(
  panels,
  shape = "rcollapse",
  gof_omit = "IC|R2")

rm("glance_custom.fixest")
```


# `align`

By default, `modelsummary` will align the first column (with coefficient names) to the left, and will center the results columns. To change this default, you can use the align argument, which accepts a string of the same length as the number of columns:

```{r, eval=FALSE}
modelsummary(models, align="lrrrrr")
```

Users who produce PDF documents using Rmarkdown or LaTeX can also align values on the decimal dot by using the character "d" in the `align` argument:

```{r, eval=FALSE}
modelsummary(models, align="lddddd")
```

See `?modelsummary` for a list of commands which need to appear in the LaTeX preamble to compile tables like this one.

# `notes`

Add notes to the bottom of your table:

```r
modelsummary(models, 
   notes = list('Text of the first note.', 
                'Text of the second note.'))
```

# `title`

You can add a title to your table as follows:

```r
modelsummary(models, title = 'This is a title for my table.')
```

# `add_rows`

Use the `add_rows` argument to add rows manually to a table. For example, let's say you estimate two models with a factor variables and you want to insert (a) an empty line to identify the category of reference, and (b) customized information at the bottom of the table:

```{r}
models <- list()
models[['OLS']] <- lm(mpg ~ factor(cyl), mtcars)
models[['Logit']] <- glm(am ~ factor(cyl), mtcars, family = binomial)
```

We create a data.frame with the same number of columns as the summary table. Then, we define a "position" attribute to specify where the new rows should be inserted in the table. Finally, we pass this data.frame to the `add_rows` argument:

```{r}
library(tibble)
rows <- tribble(~term,          ~OLS,  ~Logit,
                'factor(cyl)4', '-',   '-',
                'Info',         '???', 'XYZ')
attr(rows, 'position') <- c(3, 9)

modelsummary(models, add_rows = rows)
```

# `exponentiate`

We can exponentiate their estimates using the `exponentiate` argument:

```{r}
mod_logit <- glm(am ~ mpg, data = mtcars, family = binomial)
modelsummary(mod_logit, exponentiate = TRUE)
```

We can also present exponentiated and standard models side by side by using a logical vector:

```{r}
mod_logit <- list(mod_logit, mod_logit)
modelsummary(mod_logit, exponentiate = c(TRUE, FALSE))
```

# `...` Additional arguments

All arguments passed by the user to a `modelsummary` function are pushed forward in two other functions:

1. The function which extracts model estimates.
   - By default, additional arguments are pushed forward to `parameters::parameters` and `performance::performance`. Users can also can also use a different "backend" to extract information from model objects: the `broom` package. By setting the `modelsummary_get` global option, we tell `modelsummary` to use the `easystats`/`parameters` packages instead of `broom`. With these packages, other arguments are available, such as the `metrics` argument. Please refer to these package's documentation to details.
2. The table-making functions.
   - By default, additional arguments are pushed forward to `kableExtra::kbl`, but users can use a different table-making function by setting the `output` argument to a different value such as `"gt"`, `"flextable"`, or `"huxtable"`.
   - See [the Appearance vignette](https://modelsummary.com/vignettes/appearance.html) for examples.

All arguments passed supported by these functions are thus automatically available directly in `modelsummary`, `modelplot`, and the `datasummary` family of functions.

## Reference categories

When estimating models with factor regressors, `R` will typically omit the reference category. We can include an empty row for the reference level automatically by using the `include_reference` argument. This argument is supplied by the `parameters` package, which `modelsummary` uses behind the scenes to extract model estimates. We can supply it directly to `modelsummary()`, which will then pass the argument forward automatically:

```{r}
tmp <- transform(mtcars, cyl = factor(cyl))
mod <- lm(mpg ~ cyl, tmp)
modelsummary(mod, include_reference = TRUE)
```

## Standardization

In some cases, it is useful to standardize coefficients before reporting them. `modelsummary` extracts coefficients from model objects using the `parameters` package, and that package offers several options for standardization: https://easystats.github.io/parameters/reference/model_parameters.default.html

We can pass the `standardize` argument directly to `modelsummary` or `modelplot`, and that argument will be forwarded to `parameters`. For example to refit the model on standardized data and plot the results, we can do:

```{r}
mod <- lm(mpg ~ hp + am, data = mtcars)

modelplot(mod, standardize = "refit")
```

Compare to the unstandardized plot:

```{r}
modelplot(mod)
```

# Math

We can display math in tables by enclosing math expressions in dollars signs and setting the argument `escape=FALSE`:

```{r}
res <- lm(wt ~ mpg + drat, mtcars)

modelsummary(
  res,
  escape = FALSE,
  title = "Another math expression: $\\sum_{i=1}^n x^-i$",
  coef_rename = c("mpg" = "$\\beta_1$"))
```

# Themes and styles

To customize the appearance of tables, `modelsummary` supports six popular and extremely powerful table-making packages: 

1. [`tinytable`: https://vincentarelbundock.github.io/tinytable/](https://vincentarelbundock.github.io/tinytable/)
1. [`gt`: https://gt.rstudio.com](https://gt.rstudio.com)
1. [`kableExtra`: http://haozhu233.github.io/kableExtra](http://haozhu233.github.io/kableExtra)
1. [`huxtable`: https://hughjonesd.github.io/huxtable/](https://hughjonesd.github.io/huxtable/)
1. [`flextable`: https://davidgohel.github.io/flextable/](https://davidgohel.github.io/flextable/)
1. [`DT`: https://rstudio.github.io/DT](https://rstudio.github.io/DT)

The ["customizing the look of your tables" vignette](https://modelsummary.com/vignettes/appearance.html) shows examples for all 4 packages.

# Supported models

`modelsummary` automatically supports all the models supported by the `tidy` function of the [broom package](broom.tidymodels.org) or the `parameters` function of the [parameters package](https://easystats.github.io/parameters/). The list of supported models is rapidly expanding. At the moment, it covers the following model classes:

```{r}
supported_models()
```

To see if a given model is supported, you can fit it, and then call this function:

```{r, eval=FALSE}
get_estimates(model)
```

If this function does not return a valid output, you can easily (really!!) add your own support. See the next section for a tutorial. If you do this, you may consider opening an issue on the Github website of the `broom` package: https://github.com/tidymodels/broom/issues

# Rmarkdown, Quarto, Org-Mode

## Rmarkdown

You can use `modelsummary` to insert tables into dynamic documents with `knitr` or `Rmarkdown`. This minimal .Rmd file can produce tables in PDF, HTML, or RTF documents:

* [minimal.Rmd](https://github.com/vincentarelbundock/modelsummary/blob/master/examples/minimal.Rmd)

This .Rmd file shows illustrates how to use table numbering and cross-references to produce PDF documents using `bookdown`:

* [cross_references.Rmd](https://github.com/vincentarelbundock/modelsummary/blob/master/examples/cross_references.Rmd)

This .Rmd file shows how to customize tables in PDF and HTML files using `gt` and `kableExtra` functions:

* [appearance.Rmd](https://github.com/vincentarelbundock/modelsummary/blob/master/examples/appearance.Rmd)

## Quarto

[Quarto is an open source publishing system](https://quarto.org/) built on top of Pandoc. It was designed as a "successor" to Rmarkdown, and includes useful features for technical writing, such as built-in support for cross-references. `modelsummary` works automatically with Quarto. This is a minimal document with cross-references which should render automatically to PDF, HTML, and more:

````r
---
format: pdf
title: Example
---

@tbl-mtcars shows that cars with high horse power get low miles per gallon.

```{r}
#| label: tbl-mtcars
#| tbl-cap: "Horse Powers vs. Miles per Gallon"
library(modelsummary)
mod <- lm(mpg ~ hp, mtcars)
modelsummary(mod)
```
````

## Emacs Org-Mode

You can use `modelsummary` to insert tables into Emacs Org-Mode documents, which can be exported to a variety of formats, including HTML and PDF (via LaTeX). As with anything Emacs-related, there are many ways to achieve the outcomes you want. Here is one example of an Org-Mode document which can automatically export tables to HTML and PDF without manual tweaks:

````
#+PROPERTY: header-args:R :var orgbackend=(prin1-to-string org-export-current-backend)
#+MACRO: Rtable (eval (concat "#+header: :results output " (prin1-to-string org-export-current-backend)))

{{{Rtable}}}
#+BEGIN_SRC R :exports both
library(modelsummary)
options(modelsummary_factory_default = orgbackend)

mod = lm(hp ~ mpg, data = mtcars)

modelsummary(mod)
#+END_SRC
````

The first line tells Org-mode to assign a variable called `orgbackend`. This variable will be accessible by the `R` session, and will be equal to "html" or "latex", depending on the export format.

The second line creates an Org macro which we will use to automatically add useful information to the header of source blocks. For instance, when we export to HTML, the macro will expand to `:results output html`. This tells Org-Mode to insert the last printed output from the `R` session, and to treat it as raw HTML. 

The `{{{Rtable}}}` call expands the macro to add information to the header of the block that follows.

`#+BEGIN_SRC R :exports both` says that we want to print both the original code and the output (`:exports results` would omit the code, for example).

Finally, `options(modelsummary_factory_default=orgbackend` uses the variable we defined to set the default output format. That way, we don't have to use the `output` argument every time.

One potentially issue to keep in mind is that the code above extracts the printout from the `R` console. However, when we customize tables with `kableExtra` or `gt` functions, those functions do not always return printed raw HTML or LaTeX code. Sometimes, it can be necessary to add a call to `cat` at the end of a table customization pipeline. For example:

````
{{{Rtable}}}
#+BEGIN_SRC R :exports both
library(modelsummary)
library(kableExtra)

mod = lm(hp ~ mpg, data = mtcars)

modelsummary(mod, output = orgbackend) %>%
  row_spec(1, background = "pink") %>%
  cat()
#+END_SRC
````

# Global options

Users can change the default behavior of `modelsummary` by setting global options.

Omit the note at the bottom of the table with significance threshold:

```{r, eval = FALSE}
options("modelsummary_stars_note" = FALSE)
```

Change the default output format:

```{r, eval = FALSE}
options(modelsummary_factory_default = "latex")
options(modelsummary_factory_default = "gt")
```

Change the backend packages that `modelsummary` uses to create tables in different output formats:

```{r, eval = FALSE}
options(modelsummary_factory_html = 'kableExtra')
options(modelsummary_factory_latex = 'flextable')
options(modelsummary_factory_word = 'huxtable')
options(modelsummary_factory_png = 'gt')
```

Change the packages that `modelsummary` uses to extract information from models:

```{r, eval = FALSE}
# tidymodels: broom 
options(modelsummary_get = "broom")

# easystats: performance + parameters
options(modelsummary_get = "easystats")
```

[The `appearance` vignette](https://modelsummary.com/vignettes/appearance.html#themes) shows how to set "themes" for your tables using the `modelsummary_theme_gt`, `modelsummary_theme_kableExtra`, `modelsummary_theme_flextable` and `modelsummary_theme_huxtable` global options. For example:

```{r, eval=FALSE}
library(gt)

# The ... ellipsis is required!
custom_theme <- function(x, ...) {
    x %>% gt::opt_row_striping(row_striping = TRUE)
}
options("modelsummary_theme_gt" = custom_theme)

mod <- lm(mpg ~ hp + drat, mtcars)
modelsummary(mod, output = "gt")
```

# Case studies

## Collapse control variables into an indicator

In some cases, analysts want to display a single checkmark in their table if a full set of control variables is available. This can easily be achieved with the `glance_custom` mechanism described in detail in [the extension vignette.](modelsummary_extension.html) Here is a simple example:

```{r}
library(modelsummary)

mod <- list(
  glm(am ~ hp + factor(cyl), data = mtcars, family = binomial),
  lm(mpg ~ hp + factor(cyl) + gear + qsec, data = mtcars)
)

glance_custom.lm <- function(x, ...) {
  controls <- c("gear", "qsec")
  if (all(controls %in% names(coef(x)))) {
    out <- data.frame(Controls = "✓")
  } else {
    out <- data.frame(Controls = "✗")
  }
  return(out)
}

glance_custom.glm <- glance_custom.lm

modelsummary(mod, "html", coef_omit = "qsec|gear")
```


Return to nomal:

```{r}
rm(list = c("glance_custom.glm", "glance_custom.lm"))
```


## Subgroup estimation with `nest_by`

Sometimes, it is useful to estimate multiple regression models on subsets of the data. To do this efficiently, we can use the `nest_by` function from the `dplyr` package. Then, estimate the models with `lm`, extract them and name them with `pull`, and finally summarize them with `modelsummary`:
```{r, message=FALSE, warning=FALSE}

library(tidyverse)

mtcars %>%
    nest_by(cyl) %>%
    mutate(models = list(lm(mpg ~ hp, data))) %>%
    pull(models, name = cyl) %>%
    modelsummary
```


## Bootstrap

Users often want to use estimates or standard errors that have been obtained using a custom strategy. To achieve this in an automated and replicable way, it can be useful to use the `tidy_custom` strategy described above in the "Cutomizing Existing Models" section. 

For example, we can use the `modelr` package to draw 500 resamples of a dataset, and compute bootstrap standard errors by taking the standard deviation of estimates computed in all of those resampled datasets. To do this, we defined `tidy_custom.lm` function that will automatically bootstrap any `lm` model supplied to `modelsummary`, and replace the values in the table automatically.

Note that the `tidy_custom_lm` returns a data.frame with 3 columns: `term`, `estimate`, and `std.error`: 

```{r, message=FALSE}
library("broom")
library("tidyverse")
library("modelr")

tidy_custom.lm <- function(x, ...) {
  # extract data from the model
  model.frame(x) %>%
    # draw 500 bootstrap resamples
    modelr::bootstrap(n = 500) %>%
    # estimate the model 500 times
    mutate(results = map(strap, ~ update(x, data = .))) %>%
    # extract results using `broom::tidy`
    mutate(results = map(results, tidy)) %>%
    # unnest and summarize
    unnest(results) %>%
    group_by(term) %>%
    summarize(std.error = sd(estimate),
              estimate = mean(estimate))
}

mod = list(
  lm(hp ~ mpg, mtcars) ,
  lm(hp ~ mpg + drat, mtcars))

modelsummary(mod)
```

```{r, include=FALSE}
rm("tidy_custom.lm")
```

## `fixest`: Fixed effects 

### Instrumental variable regression

One common use-case for `glance_custom` is to include additional goodness-of-fit statistics. For example, in an instrumental variable estimation computed by the `fixest` package, we may want to include an IV-Wald statistic for the first-stage regression of each endogenous regressor:

```{r, include = FALSE}
eval_fixest <- utils::packageVersion("fixest") >= "0.10.5"
```

```{r, message = FALSE, eval = eval_fixest}
library(fixest)
library(tidyverse)

# create a toy dataset
base <- iris
names(base) <- c("y", "x1", "x_endo_1", "x_inst_1", "fe")
base$x_inst_2 <- 0.2 * base$y + 0.2 * base$x_endo_1 + rnorm(150, sd = 0.5)
base$x_endo_2 <- 0.2 * base$y - 0.2 * base$x_inst_1 + rnorm(150, sd = 0.5)

# estimate an instrumental variable model
mod <- feols(y ~ x1 | fe | x_endo_1 + x_endo_2 ~ x_inst_1 + x_inst_2, base)

# custom extractor function returns a one-row data.frame (or tibble)
glance_custom.fixest <- function(x) {
  tibble(
    "Wald (x_endo_1)" = fitstat(x, "ivwald")[[1]]$stat,
    "Wald (x_endo_2)" = fitstat(x, "ivwald")[[2]]$stat
  )
}

# draw table
modelsummary(mod)
```

```{r, message = FALSE, eval = eval_fixest}
rm("glance_custom.fixest")
```

### Customizing fixed effects indicators

By default, fixed effects levels are indicated by a `X` mark at the bottom of the table. It is reasonably easy to customize this behavior by specifying a custom `glance_custom()` method.

```{r}
library(fixest)

dat <- data.frame(
  y = rnorm(1000),
  x = rnorm(1000),
  a = sample(1:10, 1000, replace = TRUE),
  b = sample(1:10, 1000, replace = TRUE)
)
mod <- feols(y ~ x | a + b, dat)

glance_custom.fixest <- function(x) {
  out <- list()
  for (v in x$fixef_vars) {
    out[[paste0("FE: ", v)]] <- "✓"
  }
  return(data.frame(out, check.names = FALSE))
}

get_gof(mod)

modelsummary(mod)
```

## Multiple imputation

`modelsummary` can pool and display analyses on several datasets imputed using the `mice` or `Amelia` packages. This code illustrates how:

```{r, message=FALSE}
library(mice)
library(Amelia)

# Download data from `Rdatasets`
url <- 'https://vincentarelbundock.github.io/Rdatasets/csv/HistData/Guerry.csv'
dat <- read.csv(url)[, c('Clergy', 'Commerce', 'Literacy')]

# Insert missing values
dat$Clergy[sample(1:nrow(dat), 10)] <- NA
dat$Commerce[sample(1:nrow(dat), 10)] <- NA
dat$Literacy[sample(1:nrow(dat), 10)] <- NA

# Impute with `mice` and `Amelia`
dat_mice <- mice(dat, m = 5, printFlag = FALSE)
dat_amelia <- amelia(dat, m = 5, p2s = 0)$imputations

# Estimate models
mod <- list()
mod[['Listwise deletion']] <- lm(Clergy ~ Literacy + Commerce, dat)
mod[['Mice']] <- with(dat_mice, lm(Clergy ~ Literacy + Commerce)) 
mod[['Amelia']] <- lapply(dat_amelia, function(x) lm(Clergy ~ Literacy + Commerce, x))

# Pool results
mod[['Mice']] <- mice::pool(mod[['Mice']])
mod[['Amelia']] <- mice::pool(mod[['Amelia']])

# Summarize
modelsummary(mod)
```

# FAQ

## Stack Overflow is useful

* [Standardized coefficients](https://stackoverflow.com/questions/72266343/how-do-i-get-standardized-beta-coefficients-using-modelsummary-in-r-and-how-to/72267006#72267006)
* [Row group labels](https://stackoverflow.com/questions/72729369/adding-coefficient-group-titles-to-modelsummary-output/72736415#72736415)
* [Customizing Word tables](https://stackoverflow.com/questions/73120996/how-to-export-kableextra-output-in-r-to-word/73123552#73123552)
* [How to add p values to `datasummary_correlation`](https://stackoverflow.com/questions/75991478/how-to-add-a-p-value-to-a-correlation-table-while-using-model-summary-package-in/75997827#75997827)
* [`htest` objects.](https://stackoverflow.com/questions/78568013/how-to-report-an-object-of-class-htest-using-modelsummary-in-r)

## Where can I get help?

First, please read the documentation in `?modelsummary` and on [the `modelsummary` website.](https://modelsummary.com/) The website includes dozens of worked examples and a lot of detailed explanation.

Second, try to [use the `[modelsummary]` tag on StackOverflow.](https://stackoverflow.com/search?tab=newest&q=%5br%5d%20modelsummary)

Third, if you think you found a bug or have a feature request, please file it on the Github issue tracker: 

## How can I add or modify statistics in a table?

See the detailed documentation in the ["Adding and Customizing Models" section of the `modelsummary` website.](https://modelsummary.com/vignettes/modelsummary.html)

## How does `modelsummary` extract estimates and goodness-of-fit statistics?

A `modelsummary` table is divided in two parts: "Estimates" (top of the table) and "Goodness-of-fit" (bottom of the table). To populate those two parts, `modelsummary` tries using the `broom`, `parameters` and `performance` packages in sequence.

Estimates:

1. Try the `broom::tidy` function to see if that package supports this model type, or if the user defined a custom `tidy` function in their global environment. If this fails...
2. Try the `parameters::model_parameters` function to see if the `parameters` package supports this model type.

Goodness-of-fit:

1. Try the `performance::model_performance` function to see if the `performance` package supports this model type.
2. Try the `broom::glance` function to see if that package supports this model type, or if the user defined a custom `glance` function in their global environment. If this fails...

You can change the order in which those steps are executed by setting a global option:

```{r, eval=FALSE}
# tidymodels: broom 
options(modelsummary_get = "broom")

# easystats: performance + parameters
options(modelsummary_get = "easystats")
```

If all of this fails, `modelsummary` will return an error message.


If you have problems with a model object, you can often diagnose the problem by running the following commands from a *clean* R session:

```r
# see if parameters and performance support your model type
library(parameters)
library(performance)
model_parameters(model)
model_performance(model)

# see if broom supports your model type
library(broom)
tidy(model)
glance(model)

# see if broom.mixed supports your model type
library(broom.mixed)
tidy(model)
glance(model)
```

If none of these options work, you can create your own `tidy` and `glance` methods, as described in the [Adding new models section.](https://modelsummary.com/vignettes/modelsummary.html#adding-new-models-1)

If one of the extractor functions does not work well or takes too long to process, you can define a new "custom" model class and choose your own extractors, as described in the [Adding new models section.](https://modelsummary.com/vignettes/modelsummary.html#adding-new-models-1)

## How can I speed up `modelsummary`?

The `modelsummary` function, by itself, is *not* slow: it should only take a couple seconds to produce a table in any output format. However, sometimes it can be computationally expensive (and long) to extract estimates and to compute goodness-of-fit statistics for your model.

The main options to speed up `modelsummary` are:

1. Set `gof_map=NA` to avoid computing expensive goodness-of-fit statistics.
2. Use the `easystats` extractor functions and the `metrics` argument to avoid computing expensive statistics (see below for an example).
3. Use parallel computation if you are summarizing multiple models. See the "Parallel computation" section in the `?modelsummary` documentation.

To diagnose the slowdown and find the bottleneck, you can try to benchmark the various extractor functions:

```{r}
library(tictoc)

data(trade)
mod <- lm(mpg ~ hp + drat, mtcars)

tic("tidy")
x <- broom::tidy(mod)
toc()

tic("glance")
x <- broom::glance(mod)
toc()

tic("parameters")
x <- parameters::parameters(mod)
toc()

tic("performance")
x <- performance::performance(mod)
toc()
```

In my experience, the main bottleneck tends to be computing goodness-of-fit statistics. The `performance` extractor allows users to specify a `metrics` argument to select a subset of GOF to include. Using this can speedup things considerably.

We call `modelsummary` with the `metrics` argument:

```{r}
modelsummary(mod, metrics = "rmse")
```

## Escaped LaTeX characters

Sometimes, users want to include raw LaTeX commands in their tables, such as coefficient names including math mode: `Apple $\times$ Orange`. The result of these attempts is often a weird string such as: `\$\textbackslash{}times\$` instead of proper LaTeX-rendered characters.

The source of the problem is that `kableExtra`, default table-making package in `modelsummary`, automatically escapes weird characters to make sure that your tables compile properly in LaTeX. To avoid this, we need to pass the `escape=FALSE` to `modelsummary`:

```{r, eval=FALSE}
modelsummary(mod, escape = FALSE)
```

## Bayesian models

Many bayesian models are supported out-of-the-box, including those produced by the `rstanarm` and `brms` packages. The statistics available for bayesian models are slightly different than those available for most frequentist models. Users can call `get_estimates` to see what is available:

```{r, results = "hide"}
library(rstanarm)
mod <- stan_glm(am ~ hp + drat, data = mtcars)
```

```{r}
get_estimates(mod)
```

This shows that there is no `std.error` column, but that there is a `mad` statistic (mean absolute deviation). So we can do:

```{r}
modelsummary(mod, statistic = "mad")
```

As noted in [the `modelsummary()` documentation](https://modelsummary.com/reference/modelsummary.html), model results are extracted using the `parameters` package. Users can pass additional arguments to `modelsummary()`, which will then push forward those arguments to the `parameters::parameters` function to change the results. For example, [the `parameters` documentation](https://easystats.github.io/parameters/reference/model_parameters.html) for bayesian models shows that there is a `centrality` argument, which allows users to report the mean and standard deviation of the posterior distribution, instead of the median and MAD:

```{r}
get_estimates(mod, centrality = "mean")

modelsummary(mod, statistic = "std.dev", centrality = "mean")
```

We can also get additional test statistics using the `test` argument:

```{r}
get_estimates(mod, test = c("pd", "rope"))
```

## Factor labels

Often, it is useful to include the reference level of a factor variable with an emtpy line. We can do so easily by passing the `include_reference` argument to `modelsummary()`. This argument will be pushed froward to the `parameters::model_parameters()` function which is used to extract coefficients from model objects.

In this example, we also use the `group_tt()` function from `tinytable` to add a group label identifying the factor variable:

```{r}
library(tinytable)

mod <- lm(mpg ~ hp + factor(gear), mtcars)

cr <- c(
    "hp" = "Horsepower",
    "factor(gear)3" = "3",
    "factor(gear)4" = "4",
    "factor(gear)5" = "5"
)

modelsummary(mod,
    include_reference = TRUE,
    coef_rename = cr,
    gof_map = NA) |>
    group_tt(i = list("Gears" = 5), indent = 0)
```

Tables in other shapes may require a `format_tt()` call to ensure that empty cells are filled with `-`:

```{r}
modelsummary(mod,
    include_reference = TRUE,
    shape = term ~ statistic,
    coef_rename = cr,
    gof_map = NA) |>
    format_tt(replace = list("-" = "")) |>
    group_tt(i = list("Gears" = 3), indent = 0)
```

## Footnotes in column names

To add footnotes in column names, you can modify the `notes` slot of your `tinytable` object: 

```{r}
library(tinytable)
library(modelsummary)

mod <- lm(mpg ~ qsec, mtcars)
tab <- modelsummary(mod)
tab@notes <- list("a" = list(i = 0, j = 2, text = "Hello world"))
tab
```

